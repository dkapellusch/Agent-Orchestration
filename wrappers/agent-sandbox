#!/usr/bin/env bash
# agent-sandbox - Run sandboxed container with opencode/claude auth and config mounted
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RALPH_ROOT="$(dirname "$SCRIPT_DIR")"
OPENCODE_AUTH_DIR="$HOME/.local/share/opencode"
OPENCODE_AUTH_FILE="$OPENCODE_AUTH_DIR/auth.json"
OPENCODE_CONFIG_DIR="$RALPH_ROOT/opencode-config"

# Container always uses the 'agent' user's home directory
# The container has /home/agent pre-configured with all necessary directories
CONTAINER_HOME="/home/agent"

# Container image (can be overridden via env var or --image flag)
CONTAINER_IMAGE="${SANDBOX_IMAGE:-agent-sandbox:latest}"

# Parse flags
WORK_DIR="$(pwd)"
EXTRA_MOUNTS=()
MCP_CONFIG=""
OPENCODE_MCP_CONFIG=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --dir)
            WORK_DIR="$2"
            shift 2
            ;;
        --extra-mount)
            EXTRA_MOUNTS+=("$2")
            shift 2
            ;;
        --image)
            CONTAINER_IMAGE="$2"
            shift 2
            ;;
        --mcp-config)
            MCP_CONFIG="$2"
            shift 2
            ;;
        --opencode-mcp-config)
            OPENCODE_MCP_CONFIG="$2"
            shift 2
            ;;
        *)
            # Stop parsing flags, rest is the command
            break
            ;;
    esac
done

# Check if opencode auth exists
if [[ ! -f "$OPENCODE_AUTH_FILE" ]]; then
    echo "Warning: No opencode auth found at $OPENCODE_AUTH_FILE"
    echo "Run 'opencode auth login' on host first to authenticate"
    echo ""
fi

# Note: We don't mount ~/.claude - OAuth token is passed via env var instead
# This avoids permission prompt issues from host settings not matching container paths

# Note: Shared agents from $RALPH_ROOT/agents are synced to /workspace/.opencode/agents/
# by the docker-entrypoint.sh script, so opencode-config is not required for agents

# Use -i only when stdin is a TTY (interactive)
# Use -t only when BOTH stdin and stdout are TTYs (true interactive mode)
# For piped/scripted usage, skip -t to avoid TTY stream merging issues
DOCKER_FLAGS=(--rm)
if [[ -t 0 ]] && [[ -t 1 ]]; then
    DOCKER_FLAGS=(--rm -it)
fi

# Build volume mount args as array
VOLUME_MOUNTS=(-v "$WORK_DIR:/workspace")

# Sensitive paths used by both git worktree and extra mount validation
SENSITIVE_PATHS=("/etc" "/root" "$HOME/.ssh" "$HOME/.gnupg" "$HOME/.aws" "$HOME/.kube" "$HOME/.config/gcloud" "/var/run/docker.sock")

# Check if a path matches any sensitive directory
is_sensitive_path() {
    local check_path="$1"
    for sensitive in "${SENSITIVE_PATHS[@]}"; do
        if [[ "$check_path" == "$sensitive" ]] || [[ "$check_path" == "$sensitive"/* ]]; then
            return 0
        fi
    done
    return 1
}

# Handle git worktrees - mount parent repo's .git so worktree references resolve
if [[ -f "$WORK_DIR/.git" ]]; then
    GITDIR=$(grep "^gitdir:" "$WORK_DIR/.git" | cut -d' ' -f2)
    if [[ -n "$GITDIR" && "$GITDIR" == *"/.git/worktrees/"* ]]; then
        PARENT_GIT_DIR="${GITDIR%/worktrees/*}"
        CANONICAL_PARENT=""
        if command -v realpath &>/dev/null; then
            CANONICAL_PARENT=$(realpath -m "$PARENT_GIT_DIR" 2>/dev/null || true)
        elif command -v readlink &>/dev/null; then
            CANONICAL_PARENT=$(readlink -f "$PARENT_GIT_DIR" 2>/dev/null || true)
        fi
        if [[ -n "$CANONICAL_PARENT" ]] && [[ -d "$CANONICAL_PARENT" ]] && \
           [[ "$CANONICAL_PARENT" == *"/.git" ]] && ! is_sensitive_path "$CANONICAL_PARENT"; then
            VOLUME_MOUNTS+=(-v "$CANONICAL_PARENT:$CANONICAL_PARENT:ro")
        fi
    fi
fi
if [[ -f "$OPENCODE_AUTH_FILE" ]]; then
    VOLUME_MOUNTS+=(-v "$OPENCODE_AUTH_FILE:$CONTAINER_HOME/.local/share/opencode/auth.json:ro")
fi
if [[ -d "$OPENCODE_CONFIG_DIR" ]]; then
    VOLUME_MOUNTS+=(-v "$OPENCODE_CONFIG_DIR:$CONTAINER_HOME/.config/opencode:ro")
fi
if [[ -d "$RALPH_ROOT/agents" ]]; then
    VOLUME_MOUNTS+=(-v "$RALPH_ROOT/agents:/opt/shared-agents:ro")
fi
# NOTE: We intentionally do NOT mount ~/.claude - OAuth token is passed via env var instead.
# The host's permission settings don't include /workspace paths, causing prompts even with
# --dangerously-skip-permissions. The container starts with a fresh .claude directory.

# Add extra mounts (from --extra-mount flags)
# Validate against sensitive directories to prevent accidental exposure
if [[ ${#EXTRA_MOUNTS[@]} -gt 0 ]]; then
    for mount_path in "${EXTRA_MOUNTS[@]}"; do
        # Reject symlinks to prevent bypassing sensitive path checks
        if [[ -L "$mount_path" ]]; then
            echo "Warning: Refusing to mount symlink: $mount_path (resolve it first)" >&2
            continue
        fi
        # Canonicalize the path (realpath -m does not follow symlinks)
        canonical_mount=""
        if command -v realpath &>/dev/null; then
            canonical_mount=$(realpath -m "$mount_path" 2>/dev/null || echo "$mount_path")
        elif command -v readlink &>/dev/null; then
            canonical_mount=$(readlink -f "$mount_path" 2>/dev/null || echo "$mount_path")
        else
            canonical_mount="$mount_path"
        fi
        if is_sensitive_path "$canonical_mount"; then
            echo "Warning: Refusing to mount sensitive path: $mount_path" >&2
        else
            VOLUME_MOUNTS+=(-v "$mount_path:$mount_path")
        fi
    done
fi

if [[ -n "$MCP_CONFIG" ]] && [[ -f "$MCP_CONFIG" ]]; then
    canonical_mcp=""
    if command -v realpath &>/dev/null; then
        canonical_mcp=$(realpath -m "$MCP_CONFIG" 2>/dev/null || echo "$MCP_CONFIG")
    else
        canonical_mcp="$MCP_CONFIG"
    fi
    if is_sensitive_path "$canonical_mcp"; then
        echo "Warning: Refusing to mount MCP config from sensitive path: $MCP_CONFIG" >&2
    else
        VOLUME_MOUNTS+=(-v "$MCP_CONFIG:/workspace/.mcp.json:ro")
    fi
fi

if [[ -n "$OPENCODE_MCP_CONFIG" ]] && [[ -f "$OPENCODE_MCP_CONFIG" ]]; then
    VOLUME_MOUNTS+=(-v "$OPENCODE_MCP_CONFIG:/workspace/opencode.json:ro")
fi

# Write API keys to temp env file (mode 0600) so they aren't visible in ps aux
ENV_FILE=$(mktemp -t "docker-env-XXXXXX")
chmod 600 "$ENV_FILE"
cleanup_env_file() { rm -f "$ENV_FILE"; }
trap cleanup_env_file EXIT

cat >> "$ENV_FILE" <<EOF
PYTHONUNBUFFERED=1
OPENCODE_NO_BUFFER=1
HOME=$CONTAINER_HOME
EOF
[[ -n "${ANTHROPIC_API_KEY:-}" ]] && echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" >> "$ENV_FILE"
[[ -n "${GEMINI_API_KEY:-}" ]] && echo "GEMINI_API_KEY=$GEMINI_API_KEY" >> "$ENV_FILE"
[[ -n "${GOOGLE_API_KEY:-}" ]] && echo "GOOGLE_API_KEY=$GOOGLE_API_KEY" >> "$ENV_FILE"
[[ -n "${GOOGLE_GENERATIVE_AI_API_KEY:-}" ]] && echo "GOOGLE_GENERATIVE_AI_API_KEY=$GOOGLE_GENERATIVE_AI_API_KEY" >> "$ENV_FILE"
[[ -n "${OPENAI_API_KEY:-}" ]] && echo "OPENAI_API_KEY=$OPENAI_API_KEY" >> "$ENV_FILE"

# Extract Claude Code OAuth token from macOS keychain for Max auth
if [[ -z "${ANTHROPIC_API_KEY:-}" ]] && command -v security &>/dev/null; then
    CLAUDE_CREDS=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null || true)
    if [[ -n "$CLAUDE_CREDS" ]]; then
        OAUTH_TOKEN=$(echo "$CLAUDE_CREDS" | jq -r '.claudeAiOauth.accessToken // empty' 2>/dev/null || true)
        if [[ -n "$OAUTH_TOKEN" ]]; then
            echo "CLAUDE_CODE_OAUTH_TOKEN=$OAUTH_TOKEN" >> "$ENV_FILE"
        fi
    fi
fi

# Note: --network none could be used for stricter isolation, but would break AI agent API calls
docker run "${DOCKER_FLAGS[@]}" \
    --env-file "$ENV_FILE" \
    "${VOLUME_MOUNTS[@]}" \
    -w /workspace \
    "$CONTAINER_IMAGE" \
    sh -c 'mkdir -p /workspace/.opencode && ln -sf '"$CONTAINER_HOME"'/.config/opencode/agent /workspace/.opencode/agent 2>/dev/null || true; exec stdbuf -oL -eL "$@"' _ "$@"
